### Q1. Queue는 어떤 자료구조인가요?
Queue는 선형 자료구조로, 먼저 들어온 데이터가 먼저 나가는 FIFO(선입선출) 원칙을 따르는 자료구조입니다. 일상 생활에서의 대기 줄을 생각하면 이해하기 쉽습니다. 큐에 데이터가 추가되면 큐의 끝에 추가되고, 데이터가 제거될 때는 큐의 맨 앞에서 제거됩니다. 큐는 데이터의 삽입과 삭제가 양 끝에서만 일어나는 특성을 가지고 있습니다.


### [꼬꼬무1] Array-Base와 List-Base의 경우 어떤 차이가 있나요?
Array-Base Queue는 배열을 기반으로 구현된 큐로, 배열의 인덱스를 활용하여 데이터를 삽입하고 삭제합니다. 이 때문에 데이터의 삽입과 삭제 연산이 O(1)의 시간 복잡도를 가지며, 상대적으로 간단한 구현 방식입니다. 하지만 큐의 크기를 미리 정해야 하고, 배열의 크기가 제한되어 있기 때문에 큐가 가득 차거나 비어있을 때는 삽입과 삭제가 불가능합니다.
List-Base Queue는 연결 리스트를 기반으로 구현된 큐로, 데이터의 삽입과 삭제를 위해 포인터를 사용합니다. 큐의 크기를 제한할 필요가 없으며, 동적으로 크기가 조정될 수 있습니다. 하지만 포인터를 사용하기 때문에 Array-Base에 비해 약간의 오버헤드가 발생하고, 포인터 관리를 위한 추가적인 작업이 필요합니다.

### Q2. stack은 어떤 자료구조인가요?
Stack은 또 다른 선형 자료구조로, 나중에 들어온 데이터가 먼저 나가는 LIFO(후입선출) 원칙을 따르는 자료구조입니다. 스택은 데이터의 삽입과 삭제가 같은 쪽에서 이루어지는 특징을 가지고 있습니다. 데이터가 삽입될 때는 스택의 맨 위에 삽입되고, 데이터가 제거될 때는 스택의 맨 위에서 제거됩니다. 스택은 함수 호출과 반환, 괄호 검사, 웹 브라우저의 뒤로가기 등 다양한 응용 분야에서 사용됩니다.


### Q3. Stack 두 개를 이용하여 Queue를 구현해 보세요
```java
import java.util.Stack;

class MyQueue<T> {
    private Stack<T> stack1;  // 입력 스택
    private Stack<T> stack2;  // 출력 스택

    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    public void enqueue(T item) {
        stack1.push(item);  // 입력 스택에 데이터 삽입
    }

    public T dequeue() {
        if (isEmpty()) {
            return null;  // 큐가 비어있으면 null 반환
        }

        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());  // 입력 스택의 데이터를 출력 스택으로 이동
            }
        }

        return stack2.pop();  // 출력 스택에서 데이터 제거
    }

    public boolean isEmpty() {
        return stack1.isEmpty() && stack2.isEmpty();  // 스택이 모두 비어있으면 큐가 비어있는 상태
    }
}


```

### [꼬꼬무1] 시간복잡도는 어떻게 되는지 설명해 주세요
enqueue 연산은 항상 O(1)의 시간 복잡도를 가집니다. 새로운 데이터를 입력 스택에 삽입하기만 하면 되기 때문입니다. 위 코드를 기준으로 dequeue 연산은 최악의 경우 stack2가 비어있을 때 발생하며, 이 경우에만 O(N)의 시간 복잡도를 가집니다. stack2가 비어있는 경우에만 입력 스택의 모든 데이터를 stack2로 이동해야 하기 때문입니다. 하지만 dequeue 연산이 발생하는 경우는 stack2가 비어있는 상태에서만 발생하므로, 평균적으로는 dequeue 연산 역시 O(1)의 시간 복잡도를 가진다고 할 수 있습니다.


### Q4. Queue 두 개를 이용하여 Stack를 구현해 보세요
```java
import java.util.LinkedList;
import java.util.Queue;

class MyStack<T> {
    private Queue<T> queue1;  // 데이터를 저장할 큐
    private Queue<T> queue2;  // 보조 큐

    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }

    public void push(T item) {
        queue2.add(item);  // 보조 큐에 데이터 삽입
        while (!queue1.isEmpty()) {
            queue2.add(queue1.remove());  // 기존 큐의 모든 데이터를 보조 큐로 이동
        }
        // 큐 교체
        Queue<T> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }

    public T pop() {
        if (isEmpty()) {
            return null;  // 스택이 비어있으면 null 반환
        }
        return queue1.remove();  // 큐에서 데이터 제거
    }

    public boolean isEmpty() {
        return queue1.isEmpty();  // 큐가 비어있으면 스택이 비어있는 상태
    }
}

```

### [꼬꼬무1] 시간복잡도는 어떻게 되는지 설명해 주세요
enqueue 연산은 항상 O(1)의 시간 복잡도를 가집니다. 새로운 데이터를 입력 스택에 삽입하기만 하면 되기 때문입니다.
dequeue 연산은 최악의 경우 stack2가 비어있을 때 발생하며, 이 경우에만 O(N)의 시간 복잡도를 가집니다. stack2가 비어있는 경우에만 입력 스택의 모든 데이터를 stack2로 이동해야 하기 때문입니다. 하지만 dequeue 연산이 발생하는 경우는 stack2가 비어있는 상태에서만 발생하므로, 평균적으로는 dequeue 연산 역시 O(1)의 시간 복잡도를 가진다고 할 수 있습니다.


### Queue vs Priority Queue를 비교하여 설명해 주세요
Queue는 FIFO(First-In-First-Out) 원칙을 따르는 자료구조로, 먼저 들어온 데이터가 먼저 나가는 구조입니다. 큐에 데이터를 삽입할 때는 큐의 뒤쪽에 추가되고, 데이터를 제거할 때는 큐의 앞쪽에서 제거됩니다.
Priority Queue는 우선순위에 따라 데이터를 관리하는 자료구조입니다. 각각의 데이터는 우선순위를 가지고 있으며, 우선순위가 높은 데이터가 먼저 나가는 구조입니다. 즉, 가장 우선순위가 높은 데이터를 제거하는 연산이 가장 빠른 시간에 수행됩니다.
Queue와 Priority Queue의 가장 큰 차이점은 데이터의 제거 순서입니다. Queue는 먼저 들어온 데이터가 먼저 나가지만, Priority Queue는 우선순위에 따라 데이터가 나가기 때문에 제거되는 순서가 달라집니다.
Priority Queue는 일반적으로 힙(heap)이라는 자료구조를 사용하여 구현됩니다. 힙은 우선순위를 기준으로 한 정렬된 완전 이진 트리로, 삽입과 삭제 연산이 O(log N)의 시간 복잡도를 가집니다. 따라서 Priority Queue의 삽입과 삭제 연산은 평균적으로 빠른 속도로 수행됩니다.
